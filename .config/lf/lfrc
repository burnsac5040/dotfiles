# -*- mode: sh -*-
# vim: set ts=2 sw=2 et

# ┌───────────────────────────────────────────────────────────────────────────┐
# │ Basics / General                                                          │
# └───────────────────────────────────────────────────────────────────────────┘
set shell bash        # interpreter for shell commands
set shellopts '-eu'   # exit on error
set ifs "\n"          # internal field separator / split $fs, $fx
set scrolloff 10      # space on top and bottom of screen
set icons on          # show icons next to files
set period 1          # interval to check for directory updates
set hidden on         # show hidden files by default
set incsearch o       # jump to first match after each keystroke in search
set dircounts on      # show number of items in directory instead of sie
set info "size"       # list directory information on the right
set sortby "natural"  # don't sort files in any special way
set preview on        # preview file on the right pane
set drawbox on        # draw a border around all panes
set ratios '1:2:3'    # ratio of pane widths
set hiddenfiles ".*:*.aux:*.log:*.bbl:*.bcf:*.blg:*.run.xml"

# vars that depend on environmental variables
$lf -remote "send $id set previewer ${XDG_CONFIG_HOME}/lf/scope"

# lfimg
# $lf -remote "send $id set previewer ${XDG_CONFIG_HOME}/lf/preview"
# $lf -remote "send $id set cleaner ${XDG_CONFIG_HOME}/lf/cleaner"

# stpv
# set previewer stpv
# set cleaner stpvimgclr
# &stpvimg --listen $id

# ┌───────────────────────────────────────────────────────────────────────────┐
# │ Environmental Variables                                                   │
# └───────────────────────────────────────────────────────────────────────────┘
# f = full path
# fs = selected files separated with the value of 'filesep', full path
# fx selected files
# :  read (default)  builtin/custom command
# $  shell           shell command
# %  shell-pipe      shell command running with the ui
# !  shell-wait      shell command waiting for key press
# &  shell-async     shell command running asynchronously


# ┌───────────────────────────────────────────────────────────────────────────┐
# │ Commands / Functions                                                      │
# └───────────────────────────────────────────────────────────────────────────┘
cmd open ${{
    case $(file --mime-type $f -b) in
      application/pdf|application/vnd*|application/epub*) nohup zathura $fx >/dev/null 2>&1 ;;
      application/csv) vd $fx ;;
      application/msword\
        |application/vnd.openxmlformats-officedocument.*\
        |application/vnd.oasis.opendocument.text\
        |application/vnd.ms-excel\
        |text/rtf) open -a LibreOffice.app ;;
      text/*) $EDITOR $fx;;
      image/x-xcf) nohup gimp $f >/dev/null 2>&1 ;;
      image/svg+xml) display -- $f ;;
      image/*) rotdir $f | grep -i "\.\(png\|jpg\|jpeg\|gif\|webp\|tif\|ico\)\(_large\)*$" | sxiv -ai 2>/dev/null | lf-select ;;
      audio/*) mpv --audio-display=no $f >/dev/null ;;
      video/*) nohup mpv $f -quiet >/dev/null 2>&1 ;;
      application/x-bittorrent) open -a Transmission.app ;;
      application/zlib) open ;;
      *) for f in $fx; do setsid -f $OPENER $f >/dev/null 2>/dev/null & done;;
    esac
}}


# Delete single file
cmd delete ${{
  clear
  if (whiptail --title "$(echo $fx | xargs -r basename -a)" --yesno "Delete?[y/N]" --defaultno 8 40); then
    trash-put $fx && echo "$fx deleted" &&  terminal-notifier -title "🗑️  Fle deleted" -message "$(echo $fx | xargs -r basename -a) moved to trash"

  else
    echo "$fx not deleted"
  fi
}}

# trash; no confirmation
cmd trash ${{
  clear
  files=$(printf "$fx" | tr '\n' ';')
  while [ "$files" ]; do
    file=${files%%;*}
    trash-put "$(basename "$file")"
    if [ "$files" = "$file" ]; then
      files=''
    else
      files="${files#*;}"
    fi
  done &&
  terminal-notifier -title "🗑️  File(s) deleted" -message "File(s) moved to trash" && echo "$fx deleted"
}}

# move to directory from autojump
cmd movetojump ${{
  clear
  prompt="Move to: "
  dest="$(autojump -s | tac | awk 'NR>7{print $2}' | fzf --prompt="$prompt")" &&
  for x in $fx; do
    eval mv -iv \"$x\" \"$dest\"
  done &&
  terminal-notifier -title "🚚 File(s) copied." -message "$(echo $fx | xargs -r basename -a) copied to $dest."
}}


# copy to directory from autojump
cmd copytojump ${{
  clear
  prompt="Copy to: "
  dest="$(autojump -s | tac | awk 'NR>7{print $2}' | fzf --prompt="$prompt")" &&
  for x in $fx; do
    eval cp -ivr \"$x\" \"$dest\"
  done &&
  terminal-notifier -title "🚚 File(s) copied." -message "$(echo $fx | xargs -r basename -a) copied to $dest."
}}


# paste and view progress
cmd ppaste &{{
    set -- $(lf -remote load)
    mode="$1"
    shift
    case "$mode" in
        copy)
            rsync -av --ignore-existing --progress -- "$@" . |
            stdbuf -i0 -o0 -e0 tr '\r' '\n' |
            while IFS= read -r line; do
                lf -remote "send $id echo $line"
            done
            ;;
        move) mv -n -- "$@" .;;
    esac
    lf -remote "send load"
    lf -remote "send clear"
}}


cmd br_dir ${{
  clear
  f=$(mktemp)
  res="$(broot --only-folders)"
  rm -f "$f"
  if [ -f "$res" ]; then
    cmd="select"
  elif [ -d "$res" ]; then
    cmd="cd"
  fi
  lf -remote "send $id $cmd \"$res\""
}}

cmd broot_jump ${{
  f=$(mktemp)
  res="$(broot --outcmd $f && cat $f | sed 's/cd //')"
  rm -f "$f"
  if [ -f "$res" ]; then
    cmd="select"
  elif [ -d "$res" ]; then
    cmd="cd"
  fi
  lf -remote "send $id $cmd \"$res\""
}}


cmd z ${{
  set +u
  prefix=''
  dest="$(zoxide query "$@")"
  if test -n "${dest}"; then
    lf -remote "send $id cd '${dest}'"
  else
    lf -remote "send $id echo 'Invalid directory ${dest}'"
  fi
}}


# zoxide query directory jump
cmd fzf_z ${{
  sel="$(zoxide query -l | fzf +s)"
  [ -d "$sel" ] && lf -remote "send $id cd \"$sel\""
}}

cmd zoxide_i ${{
  sel="$(zoxide query -i)"
  [ -d "$sel" ] && lf -remote "send $id cd \"$sel\""
}}


## Archive
cmd unarchive ${{
  case "$f" in
      *.zip) unzip "$f" ;;
      *.tar.gz) tar -xzvf "$f" ;;
      *.tar.bz2) tar -xjvf "$f" ;;
      *.tar.x) tar -xJvf "$f" ;;
      *.tar) tar -xvf "$f" ;;
      *) echo "Unsupported format" ;;
  esac
}}


# git
cmd git_branch ${{
    git branch | fzy | xargs git checkout
    pwd_shell=$(pwd)
    lf -remote "send $id updir"
    lf -remote "send $id cd \"$pwd_shell\""
}}


# symlinks
# y (select for copy) and P to paste soft-link
# d (select for cut) and P to paste hard-link
cmd link %{{
    set $(lf -remote load)
    mode="$1"
    shift
    if [ "$#" -lt 1 ]; then
        lf -remote "send $id echo no files to link"
        exit 0
    fi
    case "$mode" in
        copy) gln -sr -t . "$@";;
        move) gln -t . "$@";;
    esac
}}


# preview the highlighted file with quicklook
cmd ql_preview &{{
  qlmanage -p "$fx" &> /dev/null;
}}

# change permissions
cmd chmod ${{
  clear;
  printf "\nPermissions: "
  read -r ans
  for file in "$fx"
  do
    chmod $ans $file
  done
  lf -remote 'send reload'
  lf -remote 'send clear'
}}


# gpg encrypt with recipient
cmd pgp_encrypt_recipient %{{
  printf "Recipient: "
  read -r recipient
  case "$recipient" in
    "") printf "Cancelled.";;
    *) gpg --encrypt --sign --recipient "$recipient" $f;;
  esac
}}


# preview video thumbnails
cmd video_preview ${{
    cache="$(mktemp "${TMPDIR:-/tmp}/thumb_cache.XXXXX")"
    ffmpegthumbnailer -i "$f" -o "$cache" -s 0
    ~/.config/lf/other/draw_img.sh "$cache"
}}

# gpg encrypt with only password
cmd pgp_encrypt_pass ${{
  gpg --symmetric $f;
}}

# gpg decrypt
cmd pgp_decrypt ${{
  gpg --output ${f%.gpg} --decrypt $f
}}

# Encode input into  ASCII-armored output with an integrated signature
cmd pgp_sign ${{
  gpg --sign $f
}}

# Wrap input in plaintext signature
cmd pgp_sign_clear ${{
  gpg --clearsign $f
}}


# open the lfrc, and source after saving
cmd edit_config :{{
  $$EDITOR ~/.config/lf/lfrc
  source ~/.config/lf/lfrc
}}


# open the lfrc scope.sh
cmd edit_scope :{{
  $$EDITOR ~/.config/lf/scope
  source ~/.config/lf/scope
}}


# select all file in directory
cmd select-files ${{
  { echo "$fs"; find -L "$(pwd)" -mindepth 1 -maxdepth 1 -type f; } |
      if [ "$lf_hidden" = "false" ]; then
        # remove any hidden files so you only select files you can see.
        grep -v '/\.[^/]\+$'
      else
        cat
      fi |
      gsed '/^$/d' | sort | uniq -u |
      gxargs -d '\n' -r -I{} lf -remote "send $id toggle {}"
}}


# select all directories in current directory
cmd select-dirs ${{
  { echo "$fs"; find -L "$(pwd)" -mindepth 1 -maxdepth 1 -type d; } |
      if [ "$lf_hidden" = "false" ]; then
        grep -v '/\.[^/]\+$'
      else
        cat
      fi |
      gsed '/^$/d' | sort | uniq -u |
      gxargs -d '\n' -r -I{} lf -remote "send $id toggle {}"
}}


cmd zip %zip -r "$f" "$f"
cmd tar %tar cvf "$f.tar" "$f"
cmd targz %tar cvzf "$f.tar.gz" "$f"
cmd tarbz2 %tar cjvf "$f.tar.bz2" "$f"

# TODO: Create dragondrop scripts
# cmd dragon %dragon-drag-and-drop -a -x $fx
# cmd dragon-stay %dragon-drag-and-drop -a $fx
# cmd dragon-individual %dragon-drag-and-drop $fx
# cmd cpdragon %cpdragon
# cmd mvdragon %mvdragon
# cmd dlfile %dlfile

cmd rsyncto ${{ rsync -uvrP $fx root@burnsac.xyz:"$1" }}
cmd rsyncfrom ${{ rsync -uvrP root@burnsac.xyz:"$1" "$2" }}
cmd fzf_cd $lf -remote "send $id cd '$(fd . --exact-depth=1 -td -H | fzf)'"

cmd aj %lf -remote "send $id cd '$(autojump $1)'"
cmd ajfzf $lf -remote "send $id cd '$(autojump -s | tac | awk 'NR>7{print $2}' | fzf)'"
cmd fzf $clear; nvim $(fd -Hi "$1" . |  fzf)
cmd fd !clear; fd -Hi "$1"
cmd rg !clear; rg "$1"
cmd rgf !clear; rgf "$1"
cmd bulkrename $fd . | vidir -
cmd massren $massren
cmd f2 !f2 -f "$1"
cmd wim $wim "$1"
cmd mkdir %[ -n "${1}" ] && mkdir -p ${@} || echo "Argument needed"
cmd mkfile %[ -n "${1}" ] && touch ${@} || echo "Argument needed"
cmd yank-path $printf '%s' "$fx" | pbcopy && terminal-notifier -title "lf" -message "$fx copied"
cmd open-with %"$@" $fx
cmd usage $du -h -d1 | less

# ┌───────────────────────────────────────────────────────────────────────────┐
# │ Mappings                                                                  │
# └───────────────────────────────────────────────────────────────────────────┘
map m
map n
map "'"
map '"'
map d
map O
map e
map w
map i
map c
map f
map gh
map .

# File Openers
map ee $$EDITOR "$f"                            # open file in editor
map ec edit_config                              # edit & source lfrc
map ev $nvim ~/.config/nvim/init.vim            # open nvim config
map ew $nvim ~/vimwiki/index.md                 # open vimwiki
map es edit_scope                               # edit lfrc scope
map ez $nvim $ZDOTDIR/.zshrc                    # edit zshrc
map ea $nvim $ZDOTDIR/zsh-aliases               # edit zsh aliases
map b $gcp --force --suffix=.bak "$f" "$f"      # backup file
map r $rmcrap                                   # delete .DS_Store etc
map v $LESS='-iWQMXR~' bat --paging=always --theme=KimbieDark "$f"
map V push :!nvim<space>
map ? $lf -doc | bat -f                         # open lfrc docs
map gH $bat -f ~/.config/lf/mappings            # open these mappings
map Ow push :open-with<space>                   # open w/ specified program
map Op $open $PWD

map as !du -hsx * | sort -rh | bat --paging=always  # directory info
map ai !gstat $f || stat $f; echo ; du -sh $f ; echo ; file -I -b -p $f

map sf select-files
map sd select-dirs
map sr :{{ set nopreview; set ratios 1:3; }}
map sp :{{ set preview;   set ratios 1:2:3; }}
map sP :{{ set preview;   set ratios 1:2; }}
map sR :{{ set reverse!; }}

# Archive Mappings
map az zip
map at tar
map ag targz
map ab targz
map au unarchive

# Trash Mappings
map dd trash
map D delete                            # confirmation with whiptail
map te %trash-empty
map tl $trash-list | fzf
map tm $frm
map tr $ftr                            # fzf trash restore script

# Dragon Mapping [CONFIGURE]
# map dr dragon
# map ds dragon-stay
# map di dragon-individual
# map dm mvdragon
# map dc cpdragon
# map dl dlfile

# Renaming
map A rename                            # at the very end
map cn push A<c-u>                      # new rename
map I push A<c-a>                       # at the beginning
map i push A<a-b><a-b><a-f>             # before extention
map aa push A<a-b>                      # after extention
map Bb bulkrename                       # bulk rename all in directory
map Bm massren                          # bulk rename with massren
map Bf push :f2<space>
map ch chmod                            # change file permissions

# File movement
map fo push :fzf<space>   # fzf search and open
map fd push :fd<space>    # use fd to find file
map fa ajfzf              # use fzf with autojump
# map <c-b> broot_jump      # use broot to jump to directory
map n fzf_z               # fzf zioxide
map zi zoxide_i           # zoxide interactive
map zz push :z<space>     # very similar to autojump
map <c-j> push :aj<space> # auto jump
# map w $lf -remote "send $id select $(fzf)"
map w fzf_cd


# General
map . set hidden!
map p paste                     # regular
map Pl :{{ link; unselect; }}   # paste a symlink
map Pp ppaste                   # paste and preview progress
map x cut
map y copy
map Yp yank-path                # yank file path
map <enter> shell-wait
map mf push :mkfile<space>
map md push :mkdir<space>
map ms $mksc                    # make script
map Ql ql_preview               # open in quicklook (macOS)
map Qm !clear; mdcat -p $fx
map Qg !clear; glow -p $fx

map gg top -- []
map G bottom -- []
map J half-down
map K half-up
map R reload
map C clear
map U unselect

map <c-x>x $$f                              # execute file
map <c-x>X !$f                              # execute file and $PAGER output
map <c-x>l $$f | bat --paging=always -f     # execute file and bat output
map <c-x>w push :wim<space>                 # open script source code
map <c-v> $jupview -P "$f"                  # view ipynb file
map <c-x>p $cat $fx | up                    # cat file to up (unix piper)
map <c-s> shell                             # enter shell command
map <c-u> usage
map <c-f> push :rg<space>                   # search with rg
map <c-z> push :rgf<space>                 # search interactively with fzf

map Yj copytojump       # copy to directory with autojump
map Mj movetojump       # move to directory with autojump

map Mt push :rsyncto<space>                     # move things to the server
map Mf push :rsyncfrom<space>                   # move things from the server

map Sa $$XDG_CONFIG_HOME/lf/sxiv-preview "$f"   # attempt to preview all imgs

# gpg
map te pgp_encrypt_recipient
map tp pgp_encrypt_pass
map td pgp_decrypt
map ts. pgp_sign
map tsc pgp_sign_clear
map tsd pgp_sign_detach

# git
map gtb :git_branch
map gtp ${{clear; git pull --rebase || true; echo "press ENTER"; read ENTER}}
map gtz ${{clear; git status; echo "press ENTER"; read ENTER}}
map gtp ${{clear; git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit}}
map gttr ${{clear; git ls-tree -r master --name-only | bat}}
map gttt ${{clear; git ls-tree -r master --name-only | as-tree --color always | bat -p}}
map gttu ${{clear; git ls-files --other | bat}}
map gtd ${{clear; f::diff}}
map gtc ${{clear; f::clean}}
map gts ${{clear; fstat}}
map gta ${{clear; fadd}}
map gtl ${{clear; flog}}
map gtu ${{clear; funtrack}}

map gfa ${{clear; dotbare fadd -f}}
map gfs ${{clear; dotbare fstat}}
map gfu ${{clear; dotbare funtrack}}
map gftr ${{clear; dotbare ls-tree -r master --name-only | bat}}
map gftt ${{clear; dotbare ls-tree -r master --name-only | as-tree --color always | bat -p}}
map gftu ${{clear; dotbare ls-files --other | bat}}

# Movement
map gd cd ~/Documents
map gD cd ~/Downloads
map gP cd ~/Pictures
map ge cd ~/Desktop
map gW cd ~/vimwiki
map gG cd ~/projects/github
map gp cd ~/projects
map go cd ~/opt

map gc cd ~/.config
map gv cd ~/.config/nvim
map glf cd ~/.config/lf

map gC cd ~/.local/share
map glo cd ~/.local

map gE cd /etc
map gU. cd /usr/local
map gUs cd /usr/local/share

map gh cd ~

# map o &mimeopen $f
# map O $mimeopen --ask $f
