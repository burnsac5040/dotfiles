o ┌───────────────────────────────────────────────────────────────────────────┐
# │ Basics / General                                                          │
# └───────────────────────────────────────────────────────────────────────────┘
set shell bash				# interpreter for shell commands
set shellopts '-eu'		# exit on error
set ifs "\n"					# internal field separator / split $fs, $fx
set scrolloff 10			# space on top and bottom of screen
set icons             # show icons next to files
set period 1          # interval to check for directory updates
set hidden            # show hidden files by default
set incsearch         # jump to first match after each keystroke in search
set dircounts
set info size
set sortby natural
set preview           # preview file on the right pane
# set drawbox
set ratios '1:2:3'    # ratio of pane widths
# set hiddenfiles ".*:*.aux:*.log:*.bbl:*.bcf:*.blg:*.run.xml"

# vars that depend on environmental variables
$lf -remote "send $id set previewer ${XDG_CONFIG_HOME}/lf/scope"

# ┌───────────────────────────────────────────────────────────────────────────┐
# │ Environmental Variables                                                   │
# └───────────────────────────────────────────────────────────────────────────┘
# f = full path
# fs = selected files separated with the value of 'filesep', full path
# fx selected files
# :  read (default)  builtin/custom command
# $  shell           shell command
# %  shell-pipe      shell command running with the ui
# !  shell-wait      shell command waiting for key press
# &  shell-async     shell command running asynchronously


# ┌───────────────────────────────────────────────────────────────────────────┐
# │ Commands / Functions                                                      │
# └───────────────────────────────────────────────────────────────────────────┘
cmd open ${{
    case $(file --mime-type $f -b) in
			application/pdf) nohup zathura $fx >/dev/null 2>&1 ;;
			text/*) $EDITOR $fx;;
			image/x-xcf) nohup gimp $f >/dev/null 2>&1 ;;
			image/svg+xml) display -- $f ;;
			image/*) rotdir $f | grep -i "\.\(png\|jpg\|jpeg\|gif\|webp\|tif\|ico\)\(_large\)*$" | sxiv -ai 2>/dev/null | lf-select ;;
			audio/*) mpv --audio-display=no $f >/dev/null ;;
			video/*) nohup mpv $f -quiet >/dev/null 2>&1 ;;
        *) for f in $fx; do nohup $OPENER $f > /dev/null 2> /dev/null & done;;
    esac
}}


# Delete single file
cmd delete ${{
	if (whiptail --title "$(echo $fx | xargs -r basename -a)" --yesno "Delete?[y/N]" --defaultno 8 40); then
		trash-put $fx && echo "$fx deleted" && 	terminal-notifier -title "🗑️  Fle deleted" -message "$(echo $fx | xargs -r basename -a) moved to trash"

	else
		echo "$fx not deleted"
	fi
}}


cmd trash-list ${{
  trash=$(trash-list)
  whiptail --msgbox --title "Trash List" "$trash" 35 75
}}


cmd trash ${{
  files=$(printf "$fx" | tr '\n' ';')
  while [ "$files" ]; do
    # extract the substring from start of string up to delimiter.
    # this is the first "element" of the string.
    file=${files%%;*}

    trash-put "$(basename "$file")"
    # if there's only one element left, set `files` to an empty string.
    # this causes us to exit this `while` loop.
    # else, we delete the first "element" of the string from files, and move onto the next.
    if [ "$files" = "$file" ]; then
      files=''
    else
      files="${files#*;}"
    fi
  done &&
 	terminal-notifier -title "🗑️  File(s) deleted" -message "File(s) moved to trash" && echo "$fx deleted"
}}


# Whiptail Move
cmd whipmove ${{
  dest=$(whiptail --title "title" --inputbox "Where to move to?" 8 40 3>&1 1>&2 2>&3)
  for x in $fx; do
    eval mv -iv \"$x\" \"$dest\"
  done &&
 	terminal-notifier -title "🚚 File(s) moved." -message "$(echo $fx | xargs -r basename -a) moved to $dest."
}}


# Fuzzy Finder Move - Slow
cmd movetofuzzy ${{
	prompt="Where to move to?: "
	dest="$(fd -Hit d . | fzf --prompt="$prompt")" &&
	for x in $fx; do
		eval mv -iv \"$x\" \"$dest\"
	done &&
	terminal-notifier -title "🚚 File(s) moved." -message "File(s) moved to $dest."
}}


# Fzy Move - local directory
cmd moveto ${{
	prompt="Where to move to?: "
	dest="$(fd -Hit d . | fzy --prompt="$prompt")" &&
	for x in $fx; do
		eval mv -iv \"$x\" \"$dest\"
	done &&
	terminal-notifier -title "🚚 File(s) moved." -message "$(echo $fx | xargs -r basename -a) moved to $dest."
}}


# move based on preloaded directories
cmd movetopre ${{
	clear; tput cup $(($(tput lines)/3)); tput bold
	set -f
	clear; echo "Move to where?"
	dest="$(cat ${XDG_CONFIG_HOME}/shell/bm-dirs | fzf | sed 's|~|$HOME|' )" &&
	for x in $fx; do
		eval mv -iv \"$x\" \"$dest\"
	done &&
	terminal-notifier -title "🚚 File(s) moved." -message "$(echo $fx | xargs -r basename -a) moved to $dest."
}}


cmd copytopre ${{
	clear; tput cup $(($(tput lines)/3)); tput bold
	set -f
	clear; echo "Move to where?"
	dest="$(cat ${XDG_CONFIG_HOME}/shell/bm-dirs | fzf | sed 's|~|$HOME|' )" &&
	for x in $fx; do
		eval cp -ivr \"$x\" \"$dest\"
	done &&
	terminal-notifier -title "🚚 File(s) copied." -message "$(echo $fx | xargs -r basename -a) copied to $dest."
}}


cmd copytojump ${{
	clear; tput cup $(($(tput lines)/3)); tput bold
	set -f
	clear; echo "Move to where?"
	dest="$(autojump -s | tac | awk 'NR>7{print $2}' | fzf)" &&
	for x in $fx; do
		eval cp -ivr \"$x\" \"$dest\"
	done &&
	terminal-notifier -title "🚚 File(s) copied." -message "$(echo $fx | xargs -r basename -a) copied to $dest."
}}


# copy with fzy prompt
cmd copytofzf ${{
	prompt="Where to copy to?: "
	dest="$(fd -Hi -t d . '/Users/lucasburns/' | fzy --prompt="$prompt")" &&
	for x in $fx; do
		eval cp -ivr \"$x\" \"$dest\"
	done &&
	terminal-notifier -title "📋 File(s) copied." -message "File(s) copies to $dest."
}}


# paste and view progress
cmd ppaste &{{
    set -- $(lf -remote load)
    mode="$1"
    shift
    case "$mode" in
        copy)
            rsync -av --ignore-existing --progress -- "$@" . |
            stdbuf -i0 -o0 -e0 tr '\r' '\n' |
            while IFS= read -r line; do
                lf -remote "send $id echo $line"
            done
            ;;
        move) mv -n -- "$@" .;;
    esac
    lf -remote "send load"
    lf -remote "send clear"
}}


cmd fzf_jump ${{
  res="$(fd -Hit d . | fzy --prompt='Jump to location > ')"
  if [ -f "$res" ]; then
    cmd="select"
  elif [ -d "$res" ]; then
    cmd="cd"
  fi
  lf -remote "send $id $cmd \"$res\""
}}


cmd broot_jump ${{
  f=$(mktemp)
  res="$(broot --outcmd $f && cat $f | sed 's/cd //')"
  rm -f "$f"
  if [ -f "$res" ]; then
    cmd="select"
  elif [ -d "$res" ]; then
    cmd="cd"
  fi
  lf -remote "send $id $cmd \"$res\""
}}


cmd z ${{
	set +u
	prefix=''
	dest="$(zoxide query "$@")"
	if test -n "${dest}"; then
		lf -remote "send $id cd '${dest}'"
	else
		lf -remote "send $id echo 'Invalid directory ${dest}'"
	fi
}}


# zoxide query directory jump
cmd fzf_z ${{
	sel="$(zoxide query -l | fzf +s)"
	[ -d "$sel" ] && lf -remote "send $id cd \"$sel\""
}}


## Archive
cmd unarchive ${{
  case "$f" in
      *.zip) unzip "$f" ;;
      *.tar.gz) tar -xzvf "$f" ;;
      *.tar.bz2) tar -xjvf "$f" ;;
			*.tar.x) tar -xJvf "$f" ;;
      *.tar) tar -xvf "$f" ;;
      *) echo "Unsupported format" ;;
  esac
}}


# git
cmd git_branch ${{
    git branch | fzy | xargs git checkout
    pwd_shell=$(pwd)
    lf -remote "send $id updir"
    lf -remote "send $id cd \"$pwd_shell\""
}}


# symlinks
# y (select for copy) and P to paste soft-link
# d (select for cut) and P to paste hard-link
cmd link %{{
    set $(lf -remote load)
		mode="$1"
    shift
    if [ "$#" -lt 1 ]; then
        lf -remote "send $id echo no files to link"
        exit 0
    fi
    case "$mode" in
        copy) gln -sr -t . "$@";;
        move) gln -t . "$@";;
    esac
}}


# symlink without gnu coreutils
cmd paste-symlink ${{
	 load=$(lf -remote 'load')
	 mode=$(echo "$load" | sed -n '1p')
	 list=$(echo "$load" | sed '1d')
	 if [ $mode = 'copy' ]; then
			 s='' && [ ! -w . ] && s='sudo'
			 for f in $list; do
					 $s ln -s "$f" "$(pwd)/$(basename $f)"
			 done
			 lf -remote 'send load'
			 lf -remote 'send clear'
	 fi
}}


# preview the highlighted file with quicklook
cmd ql_preview &{{
  qlmanage -p "$fx" &> /dev/null;
}}

# change permissions
cmd chmod ${{
  printf "\nPermissions: "
  read -r ans
  for file in "$fx"
  do
    chmod $ans $file
  done
  lf -remote 'send reload'
	lf -remote 'send clear'
}}



# gpg encrypt with recipient
cmd pgp_encrypt_recipient %{{
  printf "Recipient: "
  read -r recipient
  case "$recipient" in
    "") printf "Cancelled.";;
    *) gpg --encrypt --sign --recipient "$recipient" $f;;
  esac
}}

# gpg encrypt with only password
cmd pgp_encrypt_pass ${{
  gpg --symmetric $f;
}}

# gpg decrypt
cmd pgp_decrypt ${{
  gpg --output ${f%.gpg} --decrypt $f
}}

# Encode input into  ASCII-armored output with an integrated signature
cmd pgp_sign ${{
  gpg --sign $f
}}

# Wrap input in plaintext signature
cmd pgp_sign_clear ${{
  gpg --clearsign $f
}}


# open the lfrc, and source after saving
cmd edit_config :{{
  $$EDITOR ~/.config/lf/lfrc
  source ~/.config/lf/lfrc
}}


# open the lfrc scope.sh
cmd edit_scope :{{
  $$EDITOR ~/.config/lf/scope
  source ~/.config/lf/scope
}}


cmd zip %zip -r "$f" "$f"
cmd tar %tar cvf "$f.tar" "$f"
cmd targz %tar cvzf "$f.tar.gz" "$f"
cmd tarbz2 %tar cjvf "$f.tar.bz2" "$f"

# TODO: Create dragondrop scripts
# cmd dragon %dragon-drag-and-drop -a -x $fx
# cmd dragon-stay %dragon-drag-and-drop -a $fx
# cmd dragon-individual %dragon-drag-and-drop $fx
# cmd cpdragon %cpdragon
# cmd mvdragon %mvdragon
# cmd dlfile %dlfile

cmd aj %lf -remote "send $id cd '$(autojump $1)'"
cmd ajfzf $lf -remote "send $id cd '$(autojump -s | tac | awk 'NR>7{print $2}' | fzf)'"
cmd fzf $nvim $(fd -Hi "$1" . |  fzy)
cmd fd !fd -Hi "$1"
cmd rg !rg "$1"
cmd bulkrename $vidir
cmd wim $wim "$1"
# cmd mkdir $mkdir -p "$(echo $* | tr ' ' '\ ')"
cmd mkdir %[ -n "${1}" ] && mkdir -p ${@} || echo "Argument needed"
cmd mkfile %[ -n "${1}" ] && touch ${@} || echo "Argument needed"
cmd yank-path $printf '%s' "$fx" | pbcopy
cmd open-with %"$@" $fx
cmd usage $du -h -d1 | less
cmd rglf $dialog --title "Search" --msgbox "$(rg --color=never ${1})" 40 80

# ┌───────────────────────────────────────────────────────────────────────────┐
# │ Mappings                                                                  │
# └───────────────────────────────────────────────────────────────────────────┘
map m
map o
map n
# map "'"
# map '"'
map d
map e
map c
map f
map gh

# File Openers
map ee $$EDITOR "$f"
map ec edit_config
map ev $nvim ~/.config/nvim/init.vim
map ew $nvim ~/vimwiki/index.md
map es edit_scope
# map b $$PAGER "$f"
map b $gcp --force --suffix=.bak "$f" "$f"
map r $rmcrap
map v $LESS='-iWQMXR~' bat --paging=always --theme=KimbieDark "$f"
map V push :!nvim<space>
map ? $lf -doc | vimpager
map gX $bat -f ~/.config/lf/mappings
map o push :open-with<space>

map as !du -hsx * | sort -rh | bat --paging=always
map ai !gstat $f || stat $f; echo ; du -sh $f ; echo ; file -I -b -p $f

# Archive Mappings
map az zip
map at tar
map ag targz
map ab targz
map au unarchive

# Trash Mappings
map dd trash
map D delete
map te %trash-empty
map tl trash-list
map tr %trash-restore

# Dragon Mapping [CONFIGURE]
map dr dragon
map ds dragon-stay
map di dragon-individual
map dm mvdragon
map dc cpdragon
map dl dlfile

# Renaming
map A rename														# at the very end
map cn push A<c-u>												# new rename
map I push A<c-a>												# at the beginning
map i push A<a-b><a-b><a-f>							# before extention
map aa push A<a-b>											# after extention
map Bs $printf '%s\n' $fx | vidir -			# rename all selected
map Bb bulkrename												# bulk rename all in directory
map ch chmod

# File movement
map fo push :fzf<space>		# fzf search and open
map fd push :fd<space>		# use fd to find file
map fa ajfzf							# use fzf with autojump
map <c-b> broot_jump			# use broot to jump to directory
map n fzf_z								# Fzf zioxide
map zz push :z<space>			# very similar to autojump
map <c-z> fzf_jump				# Fzf jump directory
map <c-j> push :aj<space> # Auto jump
map w $lf -remote "send $id select $(fzf)"

map <c-x>w push :wim<space>

# General
map . set hidden!
map p ppaste
map Pl :link
map Ps :paste-symlink
map Pp paste
map x cut
map y copy
map <c-d> yank-path
map <enter> open
map mf push :mkfile<space>
map md push :mkdir<space>
map Ql :ql_preview

map gg top
map G bottom
map R reload
map C clear
map U unselect

map <c-x>x $$f															# execute file
map <c-x>X !$f															# execute file and $PAGER output
map <c-x>l $$f | bat --paging=always -f			# execute file and bat output
map <c-x>p $cat $fx | up										# cat file to up (unix piper)
map <c-s> shell															# enter shell command
map <c-u> usage
map <c-w> push :rglf<space>
map <c-f> push :rg<space>

map Ym copytofzf
map Yp copytopre
map Yj copytojump
map Mm moveto
map Mp movetopre
map Mt whipmove

map Sa $$XDG_CONFIG_HOME/lf/sxiv-preview "$f"

# gpg
map te pgp_encrypt_recipient
map tp pgp_encrypt_pass
map td pgp_decrypt
map ts. pgp_sign
map tsc pgp_sign_clear
map tsd pgp_sign_detach

# git
map gtb :git_branch
map gtp ${{clear; git pull --rebase || true; echo "press ENTER"; read ENTER}}
map gts ${{clear; git status; echo "press ENTER"; read ENTER}}
map gtl ${{clear; git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit}}
map gtt ${{clear; fstat}}
map gta ${{clear; fadd}}
map gtx ${{clear; f::add}}
map gtd ${{clear; f::diff}}
map gto ${{clear; f::log}}
map gtc ${{clear; f::clean}}
map gtu ${{clear; funtrack}}

# Movement
map gd cd ~/Documents
map gD cd ~/Downloads
map gP cd ~/Pictures
map ge cd ~/Desktop
map gW cd ~/vimwiki
map gG cd ~/projects/github
map gp cd ~/projects
map go cd ~/opt

map gc cd ~/.config
map gv cd ~/.config/nvim
map glf cd ~/.config/lf

map gC cd ~/.local/share
map glo cd ~/.local

map gE cd /etc
map gU. cd /usr/local
map gUs cd /usr/local/share

map gh cd ~

# map o &mimeopen $f
# map O $mimeopen --ask $f
