# ┌───────────────────────────────────────────────────────────────────────────┐
# │ Basics / General                                                          │
# └───────────────────────────────────────────────────────────────────────────┘
set shell bash				# interpreter for shell commands
set shellopts '-eu'		# exit on error
set ifs "\n"					# internal field separator / split $fs, $fx
set scrolloff 10			# space on top and bottom of screen
set icons             # show icons next to files
set period 1          # interval to check for directory updates
set hidden            # show hidden files by default
set incsearch         # jump to first match after each keystroke in search
set dircounts
set info size
set sortby natural
set preview           # preview file on the right pane
set drawbox
set ratios '1:2:3'    # ratio of pane widths
# set hiddenfiles ".*:*.aux:*.log:*.bbl:*.bcf:*.blg:*.run.xml"

# vars that depend on environmental variables
$lf -remote "send $id set previewer ${XDG_CONFIG_HOME:-$HOME/.config}/lf/scope"

# ┌───────────────────────────────────────────────────────────────────────────┐
# │ Environmental Variables                                                   │
# └───────────────────────────────────────────────────────────────────────────┘
# f = full path
# fs = selected files separated with the value of 'filesep', full path
# fx selected files
# :  read (default)  builtin/custom command
# $  shell           shell command
# %  shell-pipe      shell command running with the ui
# !  shell-wait      shell command waiting for key press
# &  shell-async     shell command running asynchronously


# ┌───────────────────────────────────────────────────────────────────────────┐
# │ Commands / Functions                                                      │
# └───────────────────────────────────────────────────────────────────────────┘
cmd open ${{
    case $(file --mime-type $f -b) in
			application/pdf) nohup zathura $fx >/dev/null 2>&1 ;;
			text/*) $EDITOR $fx;;
			image/x-xcf) nohup gimp $f >/dev/null 2>&1 ;;
			image/svg+xml) display -- $f ;;
			image/*) basename $f | grep -i "\.\(png\|jpg\|jpeg\|gif\|webp\|tif\|ico\)\(_large\)*$" | sxiv -aio >/dev/null 2>&1 ;;
			audio/*) mpv --audio-display=no $f >/dev/null ;;
			video/*) nohup mpv $f -quiet >/dev/null 2>&1 ;;
        *) for f in $fx; do nohup $OPENER $f > /dev/null 2> /dev/null & done;;
    esac
}}


# Delete single file
cmd delete ${{
	if (whiptail --title "$(echo $fx | xargs -r basename -a)" --yesno "Delete?[y/N]" --defaultno 8 40); then
		trash-put $fx && echo "$fx deleted" && 	terminal-notifier -title "🗑️  Fle deleted" -message "$(echo $fx | xargs -r basename -a) moved to trash"

	else
		echo "$fx not deleted"
	fi
}}

cmd trash-list ${{
  trash=$(trash-list)
  whiptail --msgbox --title "Trash List" "$trash" 35 75
}}

cmd trash ${{
  files=$(printf "$fx" | tr '\n' ';')
  while [ "$files" ]; do
    # extract the substring from start of string up to delimiter.
    # this is the first "element" of the string.
    file=${files%%;*}

    trash-put "$(basename "$file")"
    # if there's only one element left, set `files` to an empty string.
    # this causes us to exit this `while` loop.
    # else, we delete the first "element" of the string from files, and move onto the next.
    if [ "$files" = "$file" ]; then
      files=''
    else
      files="${files#*;}"
    fi
  done &&
 	terminal-notifier -title "🗑️  File(s) deleted" -message "File(s) moved to trash" && echo "$fx deleted"
}}

# Whiptail Move
cmd whipmove ${{
  dest=$(whiptail --title "title" --inputbox "Where to move to?" 8 40 3>&1 1>&2 2>&3)
  for x in $fx; do
    eval mv -iv \"$x\" \"$dest\"
  done &&
 	terminal-notifier -title "🚚 File(s) moved." -message "$(echo $fx | xargs -r basename -a) moved to $dest."

}}

# Fuzzy Finder Move - Slow
cmd movetofuzzy ${{
	prompt="Where to move to?: "
	dest="$(fd -Hit d . | fzf --prompt="$prompt")" &&
	for x in $fx; do
		eval mv -iv \"$x\" \"$dest\"
	done &&
	terminal-notifier -title "🚚 File(s) moved." -message "File(s) moved to $dest."
}}

# Fzy Move - local directory
cmd moveto ${{
	prompt="Where to move to?: "
	dest="$(fd -Hit d . | fzy --prompt="$prompt")" &&
	for x in $fx; do
		eval mv -iv \"$x\" \"$dest\"
	done &&
	terminal-notifier -title "🚚 File(s) moved." -message "$(echo $fx | xargs -r basename -a) moved to $dest."
}}


cmd copyto ${{
	prompt="Where to copy to?: "
	dest="$(fd -Hit d . | fzy --prompt="$prompt")" &&
	for x in $fx; do
		eval cp -ivr \"$x\" \"$dest\"
	done &&
	terminal-notifier -title "📋 File(s) copied." -message "File(s) copies to $dest."
}}


cmd fzf_jump ${{
  res="$(fd -Hit d . | fzy --prompt='Jump to location')"
  if [ -f "$res" ]; then
    cmd="select"
  elif [ -d "$res" ]; then
    cmd="cd"
  fi
  lf -remote "send $id $cmd \"$res\""
}}


cmd broot_jump ${{
  f=$(mktemp)
  res="$(broot --outcmd $f && cat $f | sed 's/cd //')"
  rm -f "$f"
  if [ -f "$res" ]; then
    cmd="select"
  elif [ -d "$res" ]; then
    cmd="cd"
  fi
  lf -remote "send $id $cmd \"$res\""
}}


cmd fzf_z ${{
	sel="$(zoxide query -l | fzf +s)"
	[ -d "$sel" ] && lf -remote "send $id cd \"$sel\""
}}


## Archive
cmd unarchive ${{
  case "$f" in
      *.zip) unzip "$f" ;;
      *.tar.gz) tar -xzvf "$f" ;;
      *.tar.bz2) tar -xjvf "$f" ;;
      *.tar) tar -xvf "$f" ;;
      *) echo "Unsupported format" ;;
  esac
}}

cmd zip %zip -r "$f" "$f"
cmd tar %tar cvf "$f.tar" "$f"
cmd targz %tar cvzf "$f.tar.gz" "$f"
cmd tarbz2 %tar cjvf "$f.tar.bz2" "$f"

cmd dragon %dragon-drag-and-drop -a -x $fx
cmd dragon-stay %dragon-drag-and-drop -a $fx
cmd dragon-individual %dragon-drag-and-drop $fx
cmd cpdragon %cpdragon
cmd mvdragon %mvdragon
cmd dlfile %dlfile

cmd aj %lf -remote "send $id cd '$(autojump $1)'"
cmd fzf $vi $(fd -Hi "$1" . |  fzy)
# cmd mkdir $mkdir -p "$(echo $* | tr ' ' '\ ')"
cmd mkdir %[ -n "${1}" ] && mkdir -p ${@} || echo "Argument needed"
cmd mkfile %[ -n "${1}" ] && touch ${@} || echo "Argument needed"
cmd yank-path $printf '%s' "$fx" | pbcopy
cmd open-with %"$@" $fx
cmd usage $du -h -d1 | less

# ┌───────────────────────────────────────────────────────────────────────────┐
# │ Mappings                                                                  │
# └───────────────────────────────────────────────────────────────────────────┘
map m
map o
map n
map "'"
map '"'
map d
map c
map e
map f
map gh

# File Openers
map ee $$EDITOR "$f"
map u $view "$f"
map v $LESS='-iWQMXR~' bat --paging=always --theme=KimbieDark "$f"
map V push :!nvim<space>
map ? $lf -doc | vimpager
map gX $cat ~/.config/lf/mappings | vimpager
map o push :open-with<space>

# Archive Mappings
map az zip
map at tar
map ag targz
map ab targz
map au unarchive

# Trash Mappings
map dd trash
map D delete
map te %trash-empty
map tl trash-list
map tr %trash-restore

# Dragon Mapping
map dr dragon
map ds dragon-stay
map di dragon-individual
map dm mvdragon
map dc cpdragon
map dl dlfile

# Renaming
map A rename														# at the very end
map c push A<c-u>												# new rename
map I push A<c-a>												# at the beginning
map i push A<a-b><a-b><a-f>							# before extention
map a push A<a-b>												# after extention
map B $printf '%s\n' $fx | vidir -

# File movement
map f push :fzf<space>		# Regular fzf
map <c-b> broot_jump
map n push :fzf_z<space>	# Fzf zioxide
map <c-z> fzf_jump				# Fzf jump directory
map <c-j> push :aj<space> # Auto jump
map w $lf -remote "send $id select $(fzf)"

# General
map . set hidden!
map p paste
map x cut
map y copy
map <c-d> yank-path
map <enter> open
map mf push :mkfile<space>
map md push :mkdir<space>
map gg top
map G bottom
map R reload
map C clear
map U unselect
map <c-x> $$f															# execute file
map <c-s> shell
map <c-u> usage

map C copyto
map M moveto
map mt whipmove

# Movement
map gd cd ~/Documents
map gD cd ~/Downloads
map ge cd ~/Desktop
map gW cd ~/vimwiki

map gv cd ~/.config/nvim
map gc cd ~/.config

map gC cd ~/.local/share
map gl cd ~/.local

map gE cd /etc
map gU. cd /usr/local
map gUs cd /usr/local/share

map gh cd ~

# map o &mimeopen $f
# map O $mimeopen --ask $f
